/* -----------------02/19/01 13:51-------------------
 * Датчтк температуры DS1821 для BLACK BUG SUPER
 * --------------------------------------------------*/
#include "MegSup.h"
#pragma function=default

// ----процедуры для выполнения в IDLE ( критичы к длинным прерываниям ) ------
// только в режиме измерителя температуры
//1 инициализация режима измерителя температуры 0xEE
//2 чтение измеренного значения                 0x22
// Время выполнения CmdWrite    = 480+480+45+(8 * 61) = 1448 мкс
// Время выполнения CmdDatWrite = 480+480+45+2*(8 * 61) = 1936 мкс
// Время выполнения CmdDatRead  = 480+480+45+2*(8 * 61) = 1936 мкс

/* описание DS1821
 биты регистра состояни
D7 DONE -  Преобразование Сделанный бит. “1” = полное Преобразование, “0” = преобразование в продвижении(прогрессе).
D6  1
D5 THF  - Температура Высоко Помечает. Этот бит будет обычно “0”, но будет установлен в “1”, когда температура превышает значение TH. Это останется “1” пока не сброшено, пишущий 0 в это местоположение. Эта особенность обеспечила бы метод определения, если DS1821 когда-либо подвергался температурам выше TH. Этот бит энергонезависим, и сохранен в E2 память.
D4 TLF  - Температура Низко Помечает. Этот бит будет обычно “0”, но будет установлен в “1”, когда температура более низкая чем значение TL. Это останется “1” пока не сброшено, пишущий 0 в это местоположение. Эта особенность обеспечила бы метод определения, если DS1821 когда-либо подвергался температурам ниже TL. Этот бит энергонезависим, и сохранен в E 2 память.
D3 NVB  - Энергонезависимая память занятый флажок. “1” = Запись к E2 ячейка памяти в продвижении(прогрессе), “0” = энергонезависимая память не занята. Запись к E2 мая принимает(берется) к 10 MS.
D2 T/R* - бит режима Power-up. Если установлено в “1”, DS1821 включит в режиме термостата. Если установлено в “0”, устройство включит в 1-проводном режиме “чтения”. Этот бит энергонезависим.
D1 POL  - Знаковый разряд Вывода. “1” = активный высокий, “0” =  активный низко. Этот бит энергонезависим.
D0 1SHOT- Один Режим Выстрела. Если 1SHOT “1”, DS1821 исполнит, одно температурное преобразование на прием Начала Конвертирует(преобразовывает) T протокол. Если 1SHOT - “0”, DS1821 непрерывно исполнит температурные преобразования. Обратите внимание, что режим One Shot доступен только, когда устройство находится в 1-проводном режиме. В режиме термостата, устройство непрерывно исполняет температурные преобразования. Этот бит энергонезависим.

      ФУНКЦИИ КОМАНДЫ ПРОГРАММИРОВАНИЯ
Набор команд для DS1821 как показано в Таблице 2 следующие:
Температура Рида [ААH] - Эта команда читает содержание регистра, который содержит последний результат температурный конверсионный.
Запишите TH [01H]      - Эта команда записывает к TH (ВЫСОКАЯ ТЕМПЕРАТУРА) регистр. После издания этой команды, пользователь записывает восемь битов данных к регистру TH.
Запишите TL [02H]      - Эта команда записывает к TL (НИЗКАЯ ТЕМПЕРАТУРА) регистр. После издания этой команды, пользователь записывает восемь битов данных к регистру TL.
Рид TH [A1H]           - Эта команда читает значение TH (ВЫСОКАЯ ТЕМПЕРАТУРА) регистр. После издания этой команды, пользователь читает восемь битов подарка(настоящего) данных в регистре TH.
Рид TL [A2H]           - Эта команда читает значение TL (НИЗКАЯ ТЕМПЕРАТУРА) регистр. После издания этой команды, пользователь читает восемь битов подарка(настоящего) данных в регистре TL.
Запишите Состояние [0CH]- Эта команда записывает к регистру состояния. Это использовалось бы для очистки значений флажков THF и TLF, и установки T/R, POL и 1SHOT биты. После издания этой команды, пользователь записывает восемь разрядных данных в регистр.
Рид Состояние [ACH]       - Эта команда читает значение в регистре состояния.После издания этой команды, пользователь читает эти восемь битов настоящего в регистре состояния.
Начать преобразование T [EEH] - Эта команда начинает температурное преобразование. Никакие дальнейшие данные не требуются. В режиме One Shot, температурное преобразование будет выполнено и затем DS1821 останется неактивным. В непрерывном режиме, эта команда инициализирует непрерывные преобразования.
Остановить преобразование T [22H] - Эта команда останавливает температурное преобразование. Никакие дальнейшие данные не требуются. Эта команда может использоваться, чтобы остановить DS1821 в непрерывном конверсионном режиме. После издания этой команды, текущее температурное измерение будет закончено, и затем DS1821 останется неактивным, пока Начало Не конвертирует(преобразовывает) T,  выпущен, чтобы возобновить непрерывный режим.
*/

#define SET_TERMO        DDR_TERMO CLEAR TERMO; PORT_TERMO SET  TERMO;
#define CLEAR_TERMO      PORT_TERMO CLEAR TERMO;  DDR_TERMO SET TERMO;
#define HARD_SET_TERMO   DDR_TERMO SET TERMO; PORT_TERMO SET  TERMO;
//инициализация при старте
void InitDS1821( void )
{
   //прорт на вывод с подтяжкой
   DDR_TERMO CLEAR TERMO; //вход с подтяжкой
   PORT_TERMO SET  TERMO;
}

//число тактов зв 15 мкс (90 тактов на 6МНг )
#define TIME_15MKS   (((CLOCK*100)*15)/1000000)
//длительность сигнада RESET в тактах ( 480 мкс )
#define RESET_TIME  (TIME_15MKS*32)
//число тактов во внутренних циклах
#define LOOP_CLOCK   3
//число тактов в циклах чтения ножки
#define LOOP_CLOCK_IN  5

byte ResetDS1821( void )
{//обязательная процедура инициализации обмена
   // возвращает признак наличие датчика температуры
   // 0=ОК, не=0-неудача(код ошибки)
byte temp,temp1;
   //отменякм все предыдцщие операции
   CLEAR_TERMO;
   // RESET пауза > 480 мкс
   for( temp1 = (RESET_TIME/TIME_15MKS) ; temp1; temp1--)     // 5 тактов на цикл
      for( temp = (TIME_15MKS+4)/LOOP_CLOCK ; temp; temp--) ;     // LOOP_CLOCK тактов на цикл
   // 15-60 мкс на восстановление
   SET_TERMO;
   for( temp = 4*((TIME_15MKS+6)/LOOP_CLOCK_IN) ; temp; temp--)  // < 60 мкс (LOOP_CLOCK_IN тактов на цикл)
      if( PIN_TERMO & MOR( TERMO ) ) break; //выход встал в 1 - это хорошо
   //проверка на коротыш на линии
   if( temp == 0 )
   {//если сюда попали по окончании задержки это означает коротыш на линии DS1821 то неотвечает
      SET_TERMO; return (1);            // коротыш на линии
   }
   for( ; temp; temp--)  //остаток от задержки < 60 мкс (7 тактов на цикл)
      if( !(PIN_TERMO & MOR( TERMO )) ) break; //выход встал в 0 - это хорошо
   // проверка на присутствие DS1821
   if( temp == 0 )
   {//если сюда попали по окончании задержки это означает что DS1821 не неотвечает
      SET_TERMO; return (2);//нет PRESENT
   }
   // в течении 60-240 мкс ( 255 мкс ) DS1821 должен держать шину в 0
   // проверяем что держит шину хотябы 45 мкс
   __disable_interrupt();//чтобы прерывания не увеличили случайно врем
   for( temp = 3*((TIME_15MKS+6)/LOOP_CLOCK_IN) ; temp; temp--)  // > 45 мкс (LOOP_CLOCK_IN тактов на цикл)
      if( PIN_TERMO & MOR( TERMO ) ) break; //выход встал в 1 - это рано
   __enable_interrupt();
   if( temp )
   {//если сюда попали до окончания задержки это означает что DS1821 ответил непрваилно
      SET_TERMO; return (3);//нет PRESENT
   }
   //если сюда попали по окончании задержки это означает что DS1821 ответил прваилно
   // в течении 480 мкс нечего не делаем (пауза)
   for( temp1 = (RESET_TIME/TIME_15MKS)-4 ; temp1; temp1--)     // 5 тактов на цикл
      for( temp = (TIME_15MKS+4)/LOOP_CLOCK ; temp; temp--) ;     // LOOP_CLOCK тактов на цикл
   return( 0 ); //0=ОК, не=0-неудача(код ошибки)
}

void WriteDS1821( byte data )
{//послать данные
 byte temp,CountBit;
   // передать 8 бит данных младшими вперед
   for( CountBit = 1; CountBit; CountBit<<=1)
   {
      //на >1 мкс установить 0 (Это 6 команд на 6МГц)
      CLEAR_TERMO;
      __no_operation();
      __no_operation();
      __no_operation();
//      __no_operation();
//      __no_operation();
      __no_operation();  // 6 для надежности
      if( (data & CountBit) ) { SET_TERMO; } // если выводим 1

      for( temp = 4*((TIME_15MKS+4)/LOOP_CLOCK); temp; temp--) ;  // > 60 мкс (LOOP_CLOCK тактов на цикл)
      SET_TERMO;
   }
}
byte ReadDS1821( void )
{//прочитать данные
 byte temp,CountBit,data;
   // прочитать 8 бит данных младшими вперед
   data = 0;
   for( CountBit = 1; CountBit; CountBit<<=1)
   {
      //на >1 мкс установить 0 (Это 6 команд на 6МГц)
      __disable_interrupt();
      CLEAR_TERMO;
      __no_operation();
      __no_operation();
//      __no_operation();
//      __no_operation();
//      __no_operation();
//      __no_operation();
      __no_operation();
      __no_operation();  // 8 для надежности
      SET_TERMO; // отпустили шинку
      for( temp = (TIME_15MKS+4)/LOOP_CLOCK-3 ; temp; temp--) ;     // LOOP_CLOCK тактов на цикл
      if( (PIN_TERMO & MOR( TERMO )) )
         { data |= CountBit; } // если 1 на входе
      __enable_interrupt();
      for( temp = 3*((TIME_15MKS+4)/LOOP_CLOCK); temp; temp--) ;  // > 60 мкс (LOOP_CLOCK тактов на цикл)
   }
   return ( data );
}

byte CmdWrite( byte cmd )
{//послать сомманду
 byte temp;
   //обязательная часть передач (RESET)
   if( (temp=ResetDS1821()) ) return( temp );  // выйти по ошибке
   WriteDS1821( cmd );
   return ( 0 );
}
byte CmdDatWrite( byte cmd, byte data )
{//послать сомманду и послать данные
 byte temp;
   //обязательная часть передач (RESET)
   if( (temp = ResetDS1821()) ) return( temp );  // выйти по ошибке
   WriteDS1821( cmd );
   WriteDS1821( data );
   return ( 0 );
}
byte CmdDatRead( byte cmd, byte* pData )
{// послать комманду ипринять данные
 byte temp;
   //обязательная часть передач (RESET)
   if( (temp=ResetDS1821()) ) return( temp );  // выйти по ошибке
   WriteDS1821( cmd );
   *pData = ReadDS1821();
   return ( 0 );
}
//0x7D(+125)..0x00(+0)... 0xff(-1)..0xC9(-55)
//константа обозначающая неработоспособность датчика температуры
//#define ERROR_TERMO  0x7F
//константа для очистки незначащих бит в регистре статуса
#define TERMO_SOST_MASK 0x47
//константа нормально запрограммированного датчика получаемая после маски состояни
#define TERMO_SOST_COMP 0x42
//константа для программировани
#define TERMO_SOST_PROG 0x02

//постоянный опрос датчика температуры
byte TermoCheck( void )
{
//byte temp;
static byte DataTermo;
   //читаем состояние
   if( CmdDatRead( 0xAC, &DataTermo ) ) goto TermoErr;
   if( (DataTermo & TERMO_SOST_MASK) == TERMO_SOST_COMP )
   {//запрограммипован правильно
      //прочитать температуру
      if( CmdDatRead( 0xAA, &DataTermo ) ) goto TermoErr;
      if( CmdWrite( 0xEE ) ) goto TermoErr;
      return DataTermo;
   }else
   {//запрограммипован не правильно
      if( CmdDatWrite( 0x0C, TERMO_SOST_PROG ) ) goto TermoErr;
   }
TermoErr: //обработка ошибки датчика температуры
   return ERROR_TERMO;
}
//константа обозначающая неработоспособность датчика освещенности
//#define ERROR_CANDEL  0x7F

byte CandelCheck( void )//постоянный опрос датчика освещенности
{
   return ERROR_CANDEL;
}
/* -----------------07/13/01 21:30-------------------
 * функции вывода температуры на индикатор
 * --------------------------------------------------*/

#include "Indik2.h"
/* внешние подпрограммы на СИ                                 в файле "Indik2.c"*/
extern void SendIndicatorMem( byte cmd ); //вывод на индикатор с рамятью предыдущег выведенного символа
/*внешние данные на СИ                                        в файле "MegSup.c"*/
extern volatile byte Time01sec;             // счетчик 0.1 секунды 0...9

byte TimeTermoPrint,OldTermoPrint, TempPrint[3];
//инициализация вывода температуры
void StartTermoPrint( void )
{
   byte dec,temp;
   OldTermoPrint = 0xFF;
   dec = (signed char)TermoCheck();//постоянный опрос датчика температуры
   if ( dec == ERROR_TERMO )
   {
      TempPrint[0] = K_E;
      TempPrint[1] = K_E;
      TempPrint[2] = K_MBAD;
      TimeTermoPrint = 20;
      return;
   }
   if( (dec & 0x80 ) )
   {//отрицательная температура
      TempPrint[0] = (K_POINT|IND_SOUND_LOW);
      dec = 0 - dec;
   }else
   {//положительная температура может быть больше 100С
      if( dec > 100 ) { TempPrint[0] = (1|IND_SOUND_LOW); dec-=100;}
      else{ TempPrint[0] = K_BLANK; }
   }
   for( temp = 0; dec>=10; dec-=10,temp++) ;
   TempPrint[1] = temp|IND_SOUND_LOW; //второй разряд
   TempPrint[2] = dec|IND_SOUND_LOW;  //третий разряд
   TimeTermoPrint = 30;
}
//вывод температуры на индикатор
byte RunTermoPrint( void )
{
 byte temp;
   if( TimeTermoPrint )
   {//продолжаем вывод температуры
      temp = Time01sec;
      if( OldTermoPrint != temp )
      {
         OldTermoPrint = temp;
         temp = --TimeTermoPrint;
         if( temp > 20 ) SendIndicatorMem( TempPrint[0] );
         else if ( temp > 10 ) SendIndicatorMem( TempPrint[1] );
         else SendIndicatorMem( TempPrint[2] );
      }
      return 1; //процесс вывода температуры не закончен
   }
   return 0; //процесс вывода температуры окончен
}
//отменить вывод температуры
void StopTermoPrint( void )
{
   TimeTermoPrint = 0;
}

